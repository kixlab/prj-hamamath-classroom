import { useState, useEffect } from "react";
import { useApp } from "../../contexts/AppContext";
import { api } from "../../services/api";
import { saveResult } from "../../hooks/useStorage";
import { logUserEvent } from "../../services/eventLogger";
import { exportPdfFromGuideline } from "../../utils/exportPdf";
import { useMathJax } from "../../hooks/useMathJax";
import { formatQuestion, formatAnswer, formatVerificationResult } from "../../utils/formatting";
import styles from "./SubQs.module.css";

const IconCheck = () => (
  <svg className={styles.selectIcon} viewBox="0 0 20 20" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" aria-hidden>
    <path d="M4 10l4 4 8-8" />
  </svg>
);

interface SubQuestion {
  sub_question_id: string;
  step_id: string;
  sub_skill_id: string;
  step_name: string;
  sub_skill_name: string;
  guide_sub_question: string;
  guide_sub_answer: string;
  re_sub_question?: string;
  re_sub_answer?: string;
  verification_result?: string;
  re_verification_result?: string;
  sub_answer?: string;
}

interface Progress {
  current: number;
  total: number;
  currentStep: string;
}

export const SubQs = () => {
  const {
    currentCotData,
    currentGuidelineData,
    setCurrentGuidelineData,
    setCurrentStep,
    setLoading,
    setError,
    loading,
    error,
    preferredVersion = {},
    setPreferredVersion,
    currentProblemId,
    setFinalizedGuidelineForRubric,
    finalizedGuidelineForRubric,
  } = useApp();

  useEffect(() => {
    if (!currentProblemId) return;
    saveResult(currentProblemId, undefined, undefined, currentGuidelineData ?? undefined, preferredVersion, undefined);
  }, [currentProblemId, currentGuidelineData, preferredVersion]);

  const [progress, setProgress] = useState<Progress>({
    current: 0,
    total: 0,
    currentStep: "",
  });
  // 원본 문항 / 재생성 문항 각각에 대한 편집 상태 및 최종 선택 상태
  const [editingOriginalStates, setEditingOriginalStates] = useState<Record<string, boolean>>({});
  const [editingRegeneratedStates, setEditingRegeneratedStates] = useState<Record<string, boolean>>({});
  // 재생성 문항 비교 토글: 기본값은 "펼쳐진 상태"를 목표로 하되,
  // 실제 토글 상태는 하위문항 데이터가 로드된 뒤에 계산된다.
  const [showRegeneratedStates, setShowRegeneratedStates] = useState<Record<string, boolean>>({});
  const [hideUnselectedStates, setHideUnselectedStates] = useState<Record<string, boolean>>({});
  const [feedbackStates, setFeedbackStates] = useState<Record<string, boolean>>({});
  const [verificationStates, setVerificationStates] = useState<Record<string, boolean>>({});
  const [regeneratingStates, setRegeneratingStates] = useState<Record<string, boolean>>({});
  // B 생성 모드: 단계별로 교사 확정 후 다음 단계로 진행
  const [bMode, setBMode] = useState<boolean>(false);
  const [bVisibleCount, setBVisibleCount] = useState<number>(0);
  const [bCurrentIndex, setBCurrentIndex] = useState<number>(0); // 다음에 생성할 단계 인덱스
  const [bSubjectArea, setBSubjectArea] = useState<string | null>(null); // B 모드에서 재사용할 subject_area
  const [restAutoGenerated, setRestAutoGenerated] = useState<boolean>(false); // 나머지 자동 생성 한 번이라도 실행됐으면 true → 이후 문항 박스에서 확정/나머지 버튼 숨김
  const [isGeneratingSteps, setIsGeneratingSteps] = useState<boolean>(false); // 문항 생성 중(확정 후 다음 / 나머지 자동 생성) 시각 요소용
  const containerRef = useMathJax([(currentGuidelineData as any)?.guide_sub_questions, showRegeneratedStates, hideUnselectedStates]);

  // 최종 문항/정답 계산 (원본 + 재생성 + 편집/피드백 결과 반영)
  const getFinalQA = (subQ: SubQuestion) => {
    const originalQ = (subQ.guide_sub_question || "").trim();
    const originalA = (subQ.guide_sub_answer || "").trim();
    const reQ = (subQ.re_sub_question || "").trim();
    const reA = (subQ.re_sub_answer || "").trim();
    const preferred = preferredVersion[subQ.sub_question_id];

    let finalQuestion: string;
    let finalAnswer: string;

    if (preferred === "original") {
      finalQuestion = originalQ;
      finalAnswer = originalA;
    } else if (preferred === "regenerated") {
      finalQuestion = reQ || originalQ;
      finalAnswer = reQ ? reA || originalA : originalA;
    } else {
      // 기본 규칙: 원본/재생성 둘 다 있으면 재생성 우선
      finalQuestion = reQ || originalQ;
      finalAnswer = reQ ? reA || originalA : originalA;
    }

    return {
      finalQuestion,
      finalAnswer,
    };
  };

  // 3단계 확정: 컨펌 후 선택 반영된 하위문항 JSON 저장 → Word/PDF/루브릭 생성하기 버튼 노출
  const handleFinalize = () => {
    const confirmed = window.confirm("하위문항을 확정하시겠습니까? 확정 후 Word·PDF 다운로드와 루브릭 생성이 가능합니다.");
    if (!confirmed) return;
    try {
      const gd = currentGuidelineData as any;
      if (gd?.guide_sub_questions?.length) {
        const cot = currentCotData as any;
        const finalizedSubs = gd.guide_sub_questions.map((subQ: any) => {
          const { finalQuestion, finalAnswer } = getFinalQA(subQ);
          return {
            ...subQ,
            guide_sub_question: finalQuestion,
            guide_sub_answer: finalAnswer,
          };
        });
        const finalizedPayload = {
          problem_id: gd.problem_id ?? currentProblemId,
          main_problem: gd.main_problem ?? cot?.problem ?? null,
          main_answer: gd.main_answer ?? cot?.answer ?? null,
          grade: gd.grade ?? cot?.grade ?? null,
          subject_area: gd.subject_area ?? cot?.subject_area ?? null,
          guide_sub_questions: finalizedSubs,
        };
        setFinalizedGuidelineForRubric(finalizedPayload);
        // 확정 시 서버·사이드바에 저장 (다른 기기/새로고침 시에도 목록에 표시)
        const problemId = finalizedPayload.problem_id ?? currentProblemId;
        if (problemId) {
          const guidelineToSave = { ...gd, guide_sub_questions: finalizedSubs };
          saveResult(problemId, undefined, undefined, guidelineToSave, preferredVersion, undefined);
        }
        logUserEvent("sub_questions_finalized", {
          guide_sub_questions: finalizedSubs,
        });
      } else {
        setFinalizedGuidelineForRubric(null);
      }
    } catch (err) {
      console.error("하위문항 확정 처리 중 오류:", err);
    }
  };

  const handleGoToRubric = () => {
    setCurrentStep(4);
  };

  const handleDownloadJson = () => {
    if (!currentGuidelineData || !(currentGuidelineData as any).guide_sub_questions) {
      return;
    }

    const finalized = (currentGuidelineData as any).guide_sub_questions.map((subQ: any) => {
      const { finalQuestion, finalAnswer } = getFinalQA(subQ);
      return {
        sub_question_id: subQ.sub_question_id,
        step_id: subQ.step_id,
        sub_skill_id: subQ.sub_skill_id,
        step_name: subQ.step_name,
        sub_skill_name: subQ.sub_skill_name,
        final_question: finalQuestion,
        final_answer: finalAnswer,
      };
    });

    const data = {
      main_problem: (currentCotData as any)?.problem ?? null,
      main_answer: (currentCotData as any)?.answer ?? null,
      main_solution: (currentCotData as any)?.main_solution ?? null,
      grade: (currentCotData as any)?.grade ?? null,
      finalized_sub_questions: finalized,
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `finalized_sub_questions.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // 각 단계의 verifier + 재생성 처리. 보강된 문항(enriched)을 반환해 호출자가 이어서 사용할 수 있게 함.
  const runBackgroundVerify = async ({
    cotStep,
    subQuestion,
    matchedSubjectArea,
    considerations,
    previousSubQuestions,
  }: {
    cotStep: any;
    subQuestion: SubQuestion;
    matchedSubjectArea: string;
    considerations: string[];
    previousSubQuestions: SubQuestion[];
  }): Promise<SubQuestion> => {
    try {
      const verifyResponse = await api.verifyAndRegenerate({
        main_problem: (currentCotData as any).problem,
        main_answer: (currentCotData as any).answer,
        main_solution: (currentCotData as any).main_solution || null,
        grade: (currentCotData as any).grade,
        cot_step: {
          step_id: cotStep.step_id,
          sub_skill_id: cotStep.sub_skill_id,
          step_name: cotStep.step_name,
          step_name_en: cotStep.step_name_en || "",
          sub_skill_name: cotStep.sub_skill_name,
          step_content: cotStep.step_content,
          prompt_used: cotStep.prompt_used || null,
        },
        subject_area: matchedSubjectArea,
        considerations: considerations,
        sub_question: {
          guide_sub_question: subQuestion.guide_sub_question,
          guide_sub_answer: subQuestion.guide_sub_answer,
          sub_question_id: subQuestion.sub_question_id,
          step_id: subQuestion.step_id,
          sub_skill_id: subQuestion.sub_skill_id,
          step_name: subQuestion.step_name,
          sub_skill_name: subQuestion.sub_skill_name,
        },
        // previous_sub_questions: 재생성 문항이 존재하면 재생성 문항을 우선 사용
        previous_sub_questions: previousSubQuestions.map((q) => {
          const hasReGeneratedQ = !!(q.re_sub_question && q.re_sub_question.trim().length > 0);
          const hasReGeneratedA = !!(q.re_sub_answer && q.re_sub_answer.trim().length > 0);
          return {
            sub_question_id: q.sub_question_id,
            step_id: q.step_id,
            sub_skill_id: q.sub_skill_id,
            step_name: q.step_name,
            sub_skill_name: q.sub_skill_name,
            guide_sub_question: hasReGeneratedQ ? q.re_sub_question! : q.guide_sub_question,
            guide_sub_answer: hasReGeneratedA ? q.re_sub_answer! : q.guide_sub_answer,
          };
        }),
        skip_regeneration: false,
      });

      let enrichedSubQuestion: SubQuestion = { ...subQuestion };

      if ((verifyResponse as any).was_regenerated) {
        const verificationResults = (verifyResponse as any).verification_results || {};
        const verifierNames: Record<string, string> = {
          stage_elicitation: "Stage Elicitation",
          context_alignment: "Context Alignment",
          answer_validity: "Answer Validity",
          prompt_validity: "Prompt Validity",
        };

        const allFeedbacks: string[] = [];
        for (const [key, result] of Object.entries(verificationResults)) {
          const verifierName = verifierNames[key] || key;
          const resultData = result as any;
          const scoreStr = resultData.score !== null ? resultData.score : "N/A";
          const evalSummary = resultData.evaluation_summary || "";
          const improveSuggestions = resultData.improvement_suggestions || "";
          if (evalSummary || improveSuggestions) {
            allFeedbacks.push(`[${verifierName}] 점수: ${scoreStr}\n[평가 요약]\n${evalSummary}\n[개선 제안]\n${improveSuggestions}`);
          } else {
            allFeedbacks.push(`[${verifierName}] 점수: ${scoreStr}, ${resultData.feedback || ""}`);
          }
        }

        enrichedSubQuestion = {
          ...enrichedSubQuestion,
          re_sub_question: (verifyResponse as any).sub_question?.re_sub_question || (verifyResponse as any).sub_question?.guide_sub_question,
          re_sub_answer: (verifyResponse as any).sub_question?.re_sub_answer || (verifyResponse as any).sub_question?.guide_sub_answer,
          re_verification_result: allFeedbacks.join("\n"),
          verification_result: formatVerificationResult(
            Object.entries(verificationResults)
              .map(([key, result]) => {
                const verifierName = verifierNames[key] || key;
                const resultData = result as any;
                const scoreStr = resultData.score !== null ? resultData.score : "N/A";
                const evalSummary = resultData.evaluation_summary || "";
                const improveSuggestions = resultData.improvement_suggestions || "";
                if (evalSummary || improveSuggestions) {
                  return `[${verifierName}] 점수: ${scoreStr}\n[평가 요약]\n${evalSummary}\n[개선 제안]\n${improveSuggestions}`;
                }
                return `[${verifierName}] 점수: ${scoreStr}, ${resultData.feedback || ""}`;
              })
              .join("\n"),
          ),
        };
      } else {
        // 재생성되지 않은 경우에도 검증 결과 저장
        const verificationResults = (verifyResponse as any).verification_results || {};
        const verifierNames: Record<string, string> = {
          stage_elicitation: "Stage Elicitation",
          context_alignment: "Context Alignment",
          answer_validity: "Answer Validity",
          prompt_validity: "Prompt Validity",
        };

        const allFeedbacks: string[] = [];
        for (const [key, result] of Object.entries(verificationResults)) {
          const verifierName = verifierNames[key] || key;
          const resultData = result as any;
          const scoreStr = resultData.score !== null ? resultData.score : "N/A";
          const evalSummary = resultData.evaluation_summary || "";
          const improveSuggestions = resultData.improvement_suggestions || "";
          if (evalSummary || improveSuggestions) {
            allFeedbacks.push(`[${verifierName}] 점수: ${scoreStr}\n[평가 요약]\n${evalSummary}\n[개선 제안]\n${improveSuggestions}`);
          } else {
            allFeedbacks.push(`[${verifierName}] 점수: ${scoreStr}, ${resultData.feedback || ""}`);
          }
        }
        // 재생성되지 않았더라도, 백엔드가 수정된 sub_question을 돌려줬다면
        // 해당 내용을 재생성 문항 박스에 표시할 수 있도록 복사해 둔다.
        enrichedSubQuestion = {
          ...enrichedSubQuestion,
          re_sub_question: (verifyResponse as any).sub_question?.re_sub_question || (verifyResponse as any).sub_question?.guide_sub_question || enrichedSubQuestion.re_sub_question,
          re_sub_answer: (verifyResponse as any).sub_question?.re_sub_answer || (verifyResponse as any).sub_question?.guide_sub_answer || enrichedSubQuestion.re_sub_answer,
          verification_result: allFeedbacks.join("\n"),
        };
      }

      // 로컬/기존 subQuestion에도 재생성 결과를 반영해서 이후 단계의 previous_sub_questions 계산에 활용
      Object.assign(subQuestion, enrichedSubQuestion);

      // 해당 sub_question만 상태에 merge
      (setCurrentGuidelineData as any)((prev: any) => {
        if (!prev || !prev.guide_sub_questions) return prev;
        const subQuestions = prev.guide_sub_questions as SubQuestion[];
        const idx = subQuestions.findIndex((q: SubQuestion) => q.sub_question_id === enrichedSubQuestion.sub_question_id);
        if (idx === -1) return prev;

        const updatedSubQuestions = [...subQuestions];
        updatedSubQuestions[idx] = {
          ...updatedSubQuestions[idx],
          ...enrichedSubQuestion,
        };

        return {
          ...prev,
          guide_sub_questions: updatedSubQuestions,
        };
      });

      logUserEvent("sub_question_verified", {
        sub_question_id: enrichedSubQuestion.sub_question_id,
        step_id: enrichedSubQuestion.step_id,
        verification_result: enrichedSubQuestion.verification_result ?? null,
        re_verification_result: enrichedSubQuestion.re_verification_result ?? null,
        re_sub_question: enrichedSubQuestion.re_sub_question ?? null,
        re_sub_answer: enrichedSubQuestion.re_sub_answer ?? null,
      });

      setRegeneratingStates((prev) => ({
        ...prev,
        [enrichedSubQuestion.sub_question_id]: false,
      }));
      return enrichedSubQuestion;
    } catch (err: any) {
      // 백그라운드 오류는 콘솔에만 남기고 UI는 유지
      console.error("하위문항 검증/재생성 중 오류:", err.message || err);
      // 오류가 발생해도 재생성 진행 상태는 해제
      setRegeneratingStates((prev) => ({
        ...prev,
        [subQuestion.sub_question_id]: false,
      }));
      return subQuestion;
    }
  };

  const generateNextStepB = async () => {
    logUserEvent("confirm_next_clicked", {});
    if (!currentCotData || !(currentCotData as any).steps) {
      setError("CoT 데이터가 없습니다.");
      return;
    }

    const steps = (currentCotData as any).steps;
    const stepOrder = ["1-1", "1-2", "2-1", "2-2", "3-1", "3-2", "4-1", "4-2"];

    // 이미 모든 단계를 생성했다면 종료
    if (bCurrentIndex >= steps.length) {
      return;
    }

    setError(null);
    setIsGeneratingSteps(true);
    try {
      // B 모드에서도 subject_area는 한 번만 계산해서 재사용
      let matchedSubjectArea = bSubjectArea;
      const considerations = (currentCotData as any).considerations || [];

      if (!matchedSubjectArea) {
        setProgress({ current: 0, total: 8, currentStep: "수학 영역 매칭 중..." });
        const achievementData = await api.matchSubjectArea({
          main_problem: (currentCotData as any).problem,
          main_answer: (currentCotData as any).answer,
          main_solution: (currentCotData as any).main_solution || null,
          grade: (currentCotData as any).grade,
        });
        matchedSubjectArea = achievementData.subject_area || (currentCotData as any).subject_area;
        setBSubjectArea(matchedSubjectArea);
      }
      const subjectArea: string = matchedSubjectArea ?? "";

      const guideSubQuestions: SubQuestion[] = ((currentGuidelineData as any)?.guide_sub_questions as SubQuestion[]) || [];

      const index = bCurrentIndex;
      const cotStep = steps[index];
      const stepId = stepOrder[index];

      setProgress({
        current: index + 1,
        total: 8,
        currentStep: `${stepId} 단계 처리 중...`,
      });

      // 이전 단계들에서 재생성 문항이 있다면 재생성 문항을 우선 사용
      const previousForGeneration = guideSubQuestions.map((q) => {
        const hasReGeneratedQ = !!(q.re_sub_question && q.re_sub_question.trim().length > 0);
        const hasReGeneratedA = !!(q.re_sub_answer && q.re_sub_answer.trim().length > 0);
        return {
          sub_question_id: q.sub_question_id,
          step_id: q.step_id,
          sub_skill_id: q.sub_skill_id,
          step_name: q.step_name,
          sub_skill_name: q.sub_skill_name,
          guide_sub_question: hasReGeneratedQ ? q.re_sub_question! : q.guide_sub_question,
          guide_sub_answer: hasReGeneratedA ? q.re_sub_answer! : q.guide_sub_answer,
        };
      });

      // 1단계: 현재 단계의 원본문항 생성
      const guidelineResponse = await api.generateSingleSubQuestion({
        main_problem: (currentCotData as any).problem,
        main_answer: (currentCotData as any).answer,
        main_solution: (currentCotData as any).main_solution || null,
        grade: (currentCotData as any).grade,
        cot_step: {
          step_id: cotStep.step_id,
          sub_skill_id: cotStep.sub_skill_id,
          step_name: cotStep.step_name,
          step_name_en: cotStep.step_name_en || "",
          sub_skill_name: cotStep.sub_skill_name,
          step_content: cotStep.step_content,
          prompt_used: cotStep.prompt_used || null,
        },
        subject_area: subjectArea,
        considerations: considerations,
        previous_sub_questions: previousForGeneration,
      });

      const subQuestion: SubQuestion = guidelineResponse.sub_question;
      const previousSubQuestions = guideSubQuestions.slice();

      // 누적 + 화면 반영
      const newGuideSubQuestions = [...guideSubQuestions, subQuestion];
      const guidelineData: any = {
        main_problem: (currentCotData as any).problem,
        main_answer: (currentCotData as any).answer,
        main_solution: (currentCotData as any).main_solution || null,
        grade: (currentCotData as any).grade,
        subject_area: subjectArea,
        guide_sub_questions: newGuideSubQuestions,
      };

      (setCurrentGuidelineData as any)(guidelineData);

      logUserEvent("sub_question_generated", {
        stepId,
        sub_question_id: subQuestion.sub_question_id,
        step_name: subQuestion.step_name,
        sub_skill_name: subQuestion.sub_skill_name,
        guide_sub_question: subQuestion.guide_sub_question,
        guide_sub_answer: subQuestion.guide_sub_answer ?? null,
        subject_area: subjectArea,
      });

      setBCurrentIndex(index + 1);
      setBVisibleCount(index + 1);

      setRegeneratingStates((prev) => ({
        ...prev,
        [subQuestion.sub_question_id]: true,
      }));
      await runBackgroundVerify({
        cotStep,
        subQuestion,
        matchedSubjectArea: subjectArea,
        considerations,
        previousSubQuestions,
      });
    } catch (err: any) {
      setError(err.message || "오류가 발생했습니다.");
    } finally {
      setIsGeneratingSteps(false);
    }
  };

  const generateRemainingStepsB = async () => {
    logUserEvent("rest_auto_generate_clicked", {});
    if (!currentCotData || !(currentCotData as any).steps) {
      setError("CoT 데이터가 없습니다.");
      return;
    }
    const steps = (currentCotData as any).steps;
    const stepOrder = ["1-1", "1-2", "2-1", "2-2", "3-1", "3-2", "4-1", "4-2"];
    const totalSteps = steps.length;
    if (bCurrentIndex >= totalSteps) return;

    setRestAutoGenerated(true);
    setError(null);
    setIsGeneratingSteps(true);
    try {
      let subjectArea: string = bSubjectArea ?? "";
      if (!subjectArea) {
        const achievementData = await api.matchSubjectArea({
          main_problem: (currentCotData as any).problem,
          main_answer: (currentCotData as any).answer,
          main_solution: (currentCotData as any).main_solution || null,
          grade: (currentCotData as any).grade,
        });
        subjectArea = achievementData.subject_area || (currentCotData as any).subject_area || "";
        setBSubjectArea(subjectArea);
      }
      const considerations = (currentCotData as any).considerations || [];

      let guideSubQuestions: SubQuestion[] = [...(((currentGuidelineData as any)?.guide_sub_questions || []) as SubQuestion[])];

      for (let i = bCurrentIndex; i < totalSteps; i++) {
        const cotStep = steps[i];
        const stepId = stepOrder[i];
        setProgress({ current: i + 1, total: totalSteps, currentStep: `${stepId} 단계 처리 중...` });

        const previousForGeneration = guideSubQuestions.map((q) => {
          const hasReQ = !!(q.re_sub_question && q.re_sub_question.trim().length > 0);
          const hasReA = !!(q.re_sub_answer && q.re_sub_answer.trim().length > 0);
          return {
            sub_question_id: q.sub_question_id,
            step_id: q.step_id,
            sub_skill_id: q.sub_skill_id,
            step_name: q.step_name,
            sub_skill_name: q.sub_skill_name,
            guide_sub_question: hasReQ ? q.re_sub_question! : q.guide_sub_question,
            guide_sub_answer: hasReA ? q.re_sub_answer! : q.guide_sub_answer,
          };
        });

        const guidelineResponse = await api.generateSingleSubQuestion({
          main_problem: (currentCotData as any).problem,
          main_answer: (currentCotData as any).answer,
          main_solution: (currentCotData as any).main_solution || null,
          grade: (currentCotData as any).grade,
          cot_step: {
            step_id: cotStep.step_id,
            sub_skill_id: cotStep.sub_skill_id,
            step_name: cotStep.step_name,
            step_name_en: cotStep.step_name_en || "",
            sub_skill_name: cotStep.sub_skill_name,
            step_content: cotStep.step_content,
            prompt_used: cotStep.prompt_used || null,
          },
          subject_area: subjectArea,
          considerations,
          previous_sub_questions: previousForGeneration,
        });

        const subQuestion: SubQuestion = guidelineResponse.sub_question;
        const previousSubQuestions = guideSubQuestions.slice();
        guideSubQuestions.push(subQuestion);

        logUserEvent("sub_question_generated", {
          source: "rest_auto",
          stepId: stepOrder[i],
          sub_question_id: subQuestion.sub_question_id,
          step_name: subQuestion.step_name,
          sub_skill_name: subQuestion.sub_skill_name,
          guide_sub_question: subQuestion.guide_sub_question,
          guide_sub_answer: subQuestion.guide_sub_answer ?? null,
          subject_area: subjectArea,
        });

        (setCurrentGuidelineData as any)({
          ...currentGuidelineData,
          main_problem: (currentCotData as any).problem,
          main_answer: (currentCotData as any).answer,
          main_solution: (currentCotData as any).main_solution || null,
          grade: (currentCotData as any).grade,
          subject_area: subjectArea,
          guide_sub_questions: [...guideSubQuestions],
        });

        setBCurrentIndex(i + 1);
        setBVisibleCount(i + 1);

        setRegeneratingStates((prev) => ({ ...prev, [subQuestion.sub_question_id]: true }));
        const enriched = await runBackgroundVerify({
          cotStep,
          subQuestion,
          matchedSubjectArea: subjectArea,
          considerations,
          previousSubQuestions,
        });
        guideSubQuestions[guideSubQuestions.length - 1] = enriched;
        (setCurrentGuidelineData as any)((prev: any) => {
          if (!prev || !prev.guide_sub_questions) return prev;
          const list = prev.guide_sub_questions as SubQuestion[];
          const idx = list.findIndex((q: SubQuestion) => q.sub_question_id === enriched.sub_question_id);
          if (idx === -1) return prev;
          const next = [...list];
          next[idx] = enriched;
          return { ...prev, guide_sub_questions: next };
        });
      }
    } catch (err: any) {
      setError(err.message || "오류가 발생했습니다.");
    } finally {
      setIsGeneratingSteps(false);
    }
  };

  // 원본 편집 저장: guide_sub_question / guide_sub_answer 업데이트
  const handleSaveOriginalEdit = (subqId: string) => {
    const questionEl = document.querySelector(`textarea[data-subq-id="${subqId}"][data-type="original-question"]`) as HTMLTextAreaElement;
    const answerEl = document.querySelector(`input[data-subq-id="${subqId}"][data-type="original-answer"]`) as HTMLInputElement;

    const newQuestion = (questionEl?.value ?? "").trim();
    const newAnswer = (answerEl?.value ?? "").trim();

    (setCurrentGuidelineData as any)((prev: any) => {
      if (!prev || !prev.guide_sub_questions) return prev;
      const updated = (prev.guide_sub_questions as SubQuestion[]).map((q: SubQuestion) =>
        q.sub_question_id === subqId
          ? {
              ...q,
              guide_sub_question: newQuestion,
              guide_sub_answer: newAnswer,
            }
          : q,
      );
      return {
        ...prev,
        guide_sub_questions: updated,
      };
    });

    setEditingOriginalStates((prev) => ({
      ...prev,
      [subqId]: false,
    }));
    logUserEvent("edit_original", { subqId, newQuestion, newAnswer });
  };

  const handleSaveRegeneratedEdit = (subqId: string) => {
    const questionEl = document.querySelector(`textarea[data-subq-id="${subqId}"][data-type="regenerated-question"]`) as HTMLTextAreaElement;
    const answerEl = document.querySelector(`input[data-subq-id="${subqId}"][data-type="regenerated-answer"]`) as HTMLInputElement;

    const newQuestion = (questionEl?.value ?? "").trim();
    const newAnswer = (answerEl?.value ?? "").trim();

    (setCurrentGuidelineData as any)((prev: any) => {
      if (!prev || !prev.guide_sub_questions) return prev;
      const updated = (prev.guide_sub_questions as SubQuestion[]).map((q: SubQuestion) =>
        q.sub_question_id === subqId
          ? {
              ...q,
              re_sub_question: newQuestion,
              re_sub_answer: newAnswer,
            }
          : q,
      );
      return {
        ...prev,
        guide_sub_questions: updated,
      };
    });

    setEditingRegeneratedStates((prev) => ({
      ...prev,
      [subqId]: false,
    }));
    logUserEvent("edit_regenerated", { subqId, newQuestion, newAnswer });
  };

  const toggleOriginalEdit = (subqId: string) => {
    setEditingOriginalStates((prev) => ({
      ...prev,
      [subqId]: !prev[subqId],
    }));
  };

  const toggleRegeneratedEdit = (subqId: string) => {
    setEditingRegeneratedStates((prev) => ({
      ...prev,
      [subqId]: !prev[subqId],
    }));
  };

  const toggleFeedback = (subqId: string) => {
    setFeedbackStates((prev) => ({
      ...prev,
      [subqId]: !prev[subqId],
    }));
  };

  const toggleVerification = (subqId: string) => {
    const next = !verificationStates[subqId];
    setVerificationStates((prev) => ({
      ...prev,
      [subqId]: !prev[subqId],
    }));
    if (next && (currentGuidelineData as any)?.guide_sub_questions) {
      const subQ = (currentGuidelineData as any).guide_sub_questions.find((q: SubQuestion) => q.sub_question_id === subqId);
      if (subQ) {
        logUserEvent("verification_viewed", {
          subqId,
          verification_result: subQ.verification_result ?? null,
          re_verification_result: subQ.re_verification_result ?? null,
        });
      }
    }
  };

  const handleFeedbackRegenerate = async (subqId: string, userFeedback: string) => {
    logUserEvent("feedback_submitted", { subqId, feedbackText: userFeedback });
    if (!currentCotData || !currentGuidelineData) return;

    const subQuestions: SubQuestion[] = (currentGuidelineData as any).guide_sub_questions || [];
    const targetSubQ = subQuestions.find((q: SubQuestion) => q.sub_question_id === subqId);
    if (!targetSubQ) return;

    const cotSteps = (currentCotData as any).steps || [];
    // sub_question_id (예: '1-1')와 sub_skill_id가 일치하는 step 찾기
    let cotStep = cotSteps.find((s: any) => s.sub_skill_id === subqId);
    if (!cotStep) {
      // 매칭 실패 시 인덱스로 찾기
      const stepOrder = ["1-1", "1-2", "2-1", "2-2", "3-1", "3-2", "4-1", "4-2"];
      const index = stepOrder.indexOf(subqId);
      if (index >= 0 && index < cotSteps.length) {
        cotStep = cotSteps[index];
      } else {
        setError(`CoT 단계를 찾을 수 없습니다: ${subqId}`);
        return;
      }
    }

    setLoading(true);
    setRegeneratingStates((prev) => ({
      ...prev,
      [subqId]: true,
    }));
    setError(null);

    try {
      const regenerateResponse = await api.regenerateSingleSubQuestion({
        main_problem: (currentCotData as any).problem,
        main_answer: (currentCotData as any).answer,
        main_solution: (currentCotData as any).main_solution || null,
        grade: (currentCotData as any).grade,
        cot_step: {
          step_id: cotStep.step_id,
          sub_skill_id: cotStep.sub_skill_id,
          step_name: cotStep.step_name,
          step_name_en: cotStep.step_name_en || "",
          sub_skill_name: cotStep.sub_skill_name,
          step_content: cotStep.step_content,
          prompt_used: cotStep.prompt_used || null,
        },
        subject_area: currentGuidelineData.subject_area,
        considerations: (currentCotData as any).considerations || [],
        previous_sub_questions: subQuestions.filter((q: SubQuestion) => q.sub_question_id !== subqId),
        original_sub_question: targetSubQ,
        verification_feedbacks: [`[사용자 피드백] ${userFeedback}`],
        failing_verifiers: ["stage_elicitation", "context_alignment", "answer_validity", "prompt_validity"],
      } as any);

      // 업데이트된 하위문항으로 교체
      const updatedSubQuestions = subQuestions.map((q: SubQuestion) => (q.sub_question_id === subqId ? (regenerateResponse as any).sub_question : q));

      (setCurrentGuidelineData as any)({
        ...currentGuidelineData,
        guide_sub_questions: updatedSubQuestions,
      });

      const updated = (regenerateResponse as any).sub_question;
      logUserEvent("regenerated_output", {
        subqId,
        re_sub_question: updated?.re_sub_question ?? updated?.guide_sub_question,
        re_sub_answer: updated?.re_sub_answer ?? updated?.guide_sub_answer,
      });

      setFeedbackStates((prev) => ({
        ...prev,
        [subqId]: false,
      }));
    } catch (err: any) {
      setError(err.message || "오류가 발생했습니다.");
    } finally {
      setLoading(false);
      setRegeneratingStates((prev) => ({
        ...prev,
        [subqId]: false,
      }));
    }
  };

  if (!currentGuidelineData || !(currentGuidelineData as any).guide_sub_questions) {
    return (
      <div className={styles.guidelineContainer}>
        {(loading || isGeneratingSteps) && (
          <div className={styles.loading}>
            <div className={styles.spinner}></div>
            <div>로딩 중...</div>
            {progress.total > 0 && (
              <div className={styles.progress}>
                {progress.currentStep} ({progress.current}/{progress.total})
              </div>
            )}
          </div>
        )}
        {error && <div className={styles.error}>{error}</div>}
        {!loading && !error && !isGeneratingSteps && (
          <div className={styles.emptyState}>
            <p>하위문항이 생성되지 않았습니다.</p>
            <button
              className={styles.generateButton}
              onClick={() => {
                setBMode(true);
                setBVisibleCount(0);
                setBCurrentIndex(0);
                setBSubjectArea(null);
                setRestAutoGenerated(false);
                generateNextStepB();
              }}
            >
              하위문항 생성하기
            </button>
          </div>
        )}
      </div>
    );
  }

  // B 생성 모드일 때는 교사가 확정한 만큼만 단계별로 노출
  const allSubQuestions = ((currentGuidelineData as any).guide_sub_questions || []) as SubQuestion[];
  const visibleCount = bMode ? Math.max(1, bVisibleCount || 1) : allSubQuestions.length;
  const visibleSubQuestions = allSubQuestions.slice(0, visibleCount);
  // 하위문항이 있으면 맨 아래 "하위문항 확정하기" 버튼 노출 (마지막이 4-2가 아니어도 진입 가능)
  const showFinalizeButton = allSubQuestions.length > 0;

  const handleExportWord = async () => {
    if (!currentCotData || !finalizedGuidelineForRubric) return;
    try {
      await api.exportWordFromGuideline(currentCotData as any, finalizedGuidelineForRubric, {}, currentProblemId);
    } catch (err: any) {
      alert(err.message || "워드 파일 생성 중 오류가 발생했습니다.");
    }
  };

  const handleExportPdf = async () => {
    if (!currentCotData || !finalizedGuidelineForRubric) return;
    try {
      await exportPdfFromGuideline(currentCotData as any, finalizedGuidelineForRubric, {}, currentProblemId);
    } catch (err: any) {
      alert(err.message || "PDF 생성 중 오류가 발생했습니다.");
    }
  };

  return (
    <div className={styles.guidelineContainer} ref={containerRef}>
      {loading && (
        <div className={styles.loading}>
          <div className={styles.spinner}></div>
          <div>로딩 중...</div>
          {progress.total > 0 && (
            <div className={styles.progress}>
              {progress.currentStep} ({progress.current}/{progress.total})
            </div>
          )}
        </div>
      )}
      {error && <div className={styles.error}>{error}</div>}

      <div className={styles.guidelineSubQuestions}>
        {visibleSubQuestions.map((subQ: SubQuestion, index: number) => {
          const hasRegenerated = !!(subQ.re_sub_question && subQ.re_sub_question.trim().length > 0);
          const isOriginalEditing = editingOriginalStates[subQ.sub_question_id];
          const isRegeneratedEditing = editingRegeneratedStates[subQ.sub_question_id];
          // 토글의 디폴트는 "펼쳐진 상태"가 되도록, 값이 아직 설정되지 않았다면 true로 간주
          const showRegenerated = showRegeneratedStates[subQ.sub_question_id] ?? true;
          const hideUnselected = !!hideUnselectedStates[subQ.sub_question_id];
          const selectedVersion = preferredVersion[subQ.sub_question_id]; // 'original' | 'regenerated' | undefined
          // 기본 선택: 재생성 문항이 존재하면 재생성 문항을 기본 선택으로 간주
          const effectiveSelectedVersion = selectedVersion ?? (hasRegenerated ? ("regenerated" as "regenerated") : undefined);
          const isFeedbackOpen = feedbackStates[subQ.sub_question_id];
          const isVerificationOpen = verificationStates[subQ.sub_question_id];
          const isLastVisibleInBMode = bMode && index === visibleCount - 1;
          const isRegenerating = !!regeneratingStates[subQ.sub_question_id];

          const originalQuestion = subQ.guide_sub_question || "";
          const originalAnswer = subQ.guide_sub_answer || subQ.sub_answer || "";
          const regeneratedQuestion = subQ.re_sub_question || "";
          const regeneratedAnswer = subQ.re_sub_answer || "";

          // 카드 표시 여부 계산
          const showOriginalCard =
            !hasRegenerated || // 재생성 자체가 없으면 항상 원본만
            !hideUnselected || // 아직 "선택되지 않은 문항 숨기기"를 안 누른 상태
            effectiveSelectedVersion !== "regenerated"; // 재생성이 선택된 경우에만 원본을 숨김

          const showRegeneratedCard =
            showRegenerated && // 재생성 보기 토글이 켜져 있고
            (!hideUnselected || effectiveSelectedVersion !== "original"); // 원본이 선택된 경우에만 재생성 숨김

          return (
            <div key={subQ.sub_question_id} className={styles.subQuestionCard}>
              <div className={styles.subQuestionHeader}>
                <span className={styles.subQuestionId}>{subQ.sub_question_id}</span>
                <span className={styles.subQuestionTitle}>
                  {subQ.step_name} - {subQ.sub_skill_name}
                </span>
              </div>

              <div className={styles.questionSection}>
                {hasRegenerated ? (
                  <>
                    {showOriginalCard && (
                      <div className={`${styles.originalQuestionBox} ${effectiveSelectedVersion === "original" ? styles.selected : ""}`}>
                        <div className={styles.questionLabelRow}>
                          <div className={styles.questionLabel}>원본 문항</div>
                          <div className={styles.questionActions}>
                            {!isOriginalEditing && (
                              <button className={styles.editToggleBtn} onClick={() => toggleOriginalEdit(subQ.sub_question_id)}>
                                편집
                              </button>
                            )}
                            {showRegenerated && !hideUnselected && (
                              <button
                                type="button"
                                className={`${styles.selectBtn} ${effectiveSelectedVersion === "original" ? styles.selectBtnActive : ""}`}
                                onClick={() => {
                                  setPreferredVersion?.({ ...preferredVersion, [subQ.sub_question_id]: "original" });
                                  logUserEvent("version_selected", { subqId: subQ.sub_question_id, version: "original" });
                                  setHideUnselectedStates((prev) => ({
                                    ...prev,
                                    [subQ.sub_question_id]: true,
                                  }));
                                  setShowRegeneratedStates((prev) => ({
                                    ...prev,
                                    [subQ.sub_question_id]: true,
                                  }));
                                }}
                                title={effectiveSelectedVersion === "original" ? "선택됨" : "이 문항 선택"}
                                aria-label={effectiveSelectedVersion === "original" ? "선택됨" : "이 문항 선택"}
                              >
                                <IconCheck />
                              </button>
                            )}
                          </div>
                        </div>
                        {isOriginalEditing ? (
                          <div className={styles.editMode}>
                            <textarea className={styles.editTextarea} defaultValue={originalQuestion} rows={3} data-subq-id={subQ.sub_question_id} data-type="original-question" />
                            <input
                              type="text"
                              className={styles.editInput}
                              defaultValue={originalAnswer}
                              placeholder="정답을 입력하세요"
                              data-subq-id={subQ.sub_question_id}
                              data-type="original-answer"
                            />
                            <div className={styles.editActions}>
                              <button className={styles.cancelBtn} onClick={() => toggleOriginalEdit(subQ.sub_question_id)}>
                                취소
                              </button>
                              <button className={styles.saveBtn} onClick={() => handleSaveOriginalEdit(subQ.sub_question_id)}>
                                저장
                              </button>
                            </div>
                          </div>
                        ) : (
                          <div className={styles.displayMode}>
                            <div className={styles.questionContent}>{formatQuestion(originalQuestion)}</div>
                            {originalAnswer && (
                              <div className={styles.answerContent}>
                                <strong>정답:</strong> <span dangerouslySetInnerHTML={{ __html: formatAnswer(originalAnswer) }} />
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    )}
                    {showRegeneratedCard && (
                      <div className={`${styles.regeneratedQuestionBox} ${effectiveSelectedVersion === "regenerated" ? styles.selected : ""}`}>
                        <div className={styles.questionLabelRow}>
                          <div className={styles.questionLabel}>재생성 문항</div>
                          <div className={styles.questionActions}>
                            {!isRegeneratedEditing && (
                              <button className={styles.editToggleBtn} onClick={() => toggleRegeneratedEdit(subQ.sub_question_id)}>
                                편집
                              </button>
                            )}
                            {showRegenerated && !hideUnselected && (
                              <button
                                type="button"
                                className={`${styles.selectBtn} ${effectiveSelectedVersion === "regenerated" ? styles.selectBtnActive : ""}`}
                                onClick={() => {
                                  setPreferredVersion?.({ ...preferredVersion, [subQ.sub_question_id]: "regenerated" });
                                  logUserEvent("version_selected", { subqId: subQ.sub_question_id, version: "regenerated" });
                                  setHideUnselectedStates((prev) => ({
                                    ...prev,
                                    [subQ.sub_question_id]: true,
                                  }));
                                  setShowRegeneratedStates((prev) => ({
                                    ...prev,
                                    [subQ.sub_question_id]: true,
                                  }));
                                }}
                                title={effectiveSelectedVersion === "regenerated" ? "선택됨" : "이 문항 선택"}
                                aria-label={effectiveSelectedVersion === "regenerated" ? "선택됨" : "이 문항 선택"}
                              >
                                <IconCheck />
                              </button>
                            )}
                          </div>
                        </div>
                        {isRegeneratedEditing ? (
                          <div className={styles.editMode}>
                            <textarea className={styles.editTextarea} defaultValue={regeneratedQuestion} rows={3} data-subq-id={subQ.sub_question_id} data-type="regenerated-question" />
                            <input
                              type="text"
                              className={styles.editInput}
                              defaultValue={regeneratedAnswer}
                              placeholder="정답을 입력하세요"
                              data-subq-id={subQ.sub_question_id}
                              data-type="regenerated-answer"
                            />
                            <div className={styles.editActions}>
                              <button className={styles.cancelBtn} onClick={() => toggleRegeneratedEdit(subQ.sub_question_id)}>
                                취소
                              </button>
                              <button className={styles.saveBtn} onClick={() => handleSaveRegeneratedEdit(subQ.sub_question_id)}>
                                저장
                              </button>
                            </div>
                          </div>
                        ) : (
                          <div className={styles.displayMode}>
                            <div className={styles.questionContent}>{formatQuestion(regeneratedQuestion)}</div>
                            {regeneratedAnswer && (
                              <div className={styles.answerContent}>
                                <strong>정답:</strong> <span dangerouslySetInnerHTML={{ __html: formatAnswer(regeneratedAnswer) }} />
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    )}
                  </>
                ) : (
                  <>
                    <div className={styles.originalQuestionBox}>
                      <div className={styles.questionLabelRow}>
                        <div className={styles.questionLabel}>원본 문항</div>
                        {!isOriginalEditing && (
                          <button className={styles.editToggleBtn} onClick={() => toggleOriginalEdit(subQ.sub_question_id)}>
                            편집
                          </button>
                        )}
                      </div>
                      {isOriginalEditing ? (
                        <div className={styles.editMode}>
                          <textarea className={styles.editTextarea} defaultValue={originalQuestion} rows={3} data-subq-id={subQ.sub_question_id} data-type="original-question" />
                          <input
                            type="text"
                            className={styles.editInput}
                            defaultValue={originalAnswer}
                            placeholder="정답을 입력하세요"
                            data-subq-id={subQ.sub_question_id}
                            data-type="original-answer"
                          />
                          <div className={styles.editActions}>
                            <button className={styles.cancelBtn} onClick={() => toggleOriginalEdit(subQ.sub_question_id)}>
                              취소
                            </button>
                            <button className={styles.saveBtn} onClick={() => handleSaveOriginalEdit(subQ.sub_question_id)}>
                              저장
                            </button>
                          </div>
                        </div>
                      ) : (
                        <div className={styles.displayMode}>
                          <div className={styles.questionContent}>{formatQuestion(originalQuestion)}</div>
                          {originalAnswer && (
                            <div className={styles.answerContent}>
                              <strong>정답:</strong> <span dangerouslySetInnerHTML={{ __html: formatAnswer(originalAnswer) }} />
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                    <div className={styles.regeneratedQuestionBox}>
                      <div className={styles.questionLabelRow}>
                        <div className={styles.questionLabel}>재생성 문항</div>
                      </div>
                      <div className={styles.displayMode}>
                        <div className={styles.questionContent}>{isRegenerating ? "준비중" : "재생성한 문항이 없습니다"}</div>
                      </div>
                    </div>
                  </>
                )}
              </div>

              <div className={styles.actionButtons}>
                <div className={styles.actionRowItem}>
                  <button className={styles.actionBtn} onClick={() => toggleVerification(subQ.sub_question_id)}>
                    <span>🔍</span>
                    <span>검증 결과 보기</span>
                  </button>
                  <button className={styles.actionBtnFeedback} onClick={() => toggleFeedback(subQ.sub_question_id)}>
                    <span>💬</span>
                    <span>피드백</span>
                  </button>
                  {isFeedbackOpen && (
                    <button
                      className={styles.regenerateBtn}
                      disabled={isRegenerating}
                      onClick={() => {
                        const feedbackText = (document.querySelector(`.feedback-textarea-${subQ.sub_question_id}`) as HTMLTextAreaElement)?.value || "";
                        if (feedbackText.trim()) {
                          handleFeedbackRegenerate(subQ.sub_question_id, feedbackText);
                        }
                      }}
                    >
                      {isRegenerating ? (
                        <>
                          <span className={styles.spinnerInline} aria-hidden />
                          <span>처리 중...</span>
                        </>
                      ) : (
                        <>
                          <span>🔄</span>
                          <span>재생성</span>
                        </>
                      )}
                    </button>
                  )}
                  {!isFeedbackOpen && hasRegenerated && !isRegenerating && (
                    <button
                      className={styles.regenerateBtn}
                      onClick={() => {
                        const currentlyShown = !!showRegenerated;
                        const selected = effectiveSelectedVersion;
                        const hideUnselectedNow = !!hideUnselected;

                        if (!selected) {
                          setShowRegeneratedStates((prev) => ({
                            ...prev,
                            [subQ.sub_question_id]: !currentlyShown,
                          }));
                          setHideUnselectedStates((prev) => ({
                            ...prev,
                            [subQ.sub_question_id]: false,
                          }));
                          return;
                        }
                        if (currentlyShown && !hideUnselectedNow) {
                          setHideUnselectedStates((prev) => ({
                            ...prev,
                            [subQ.sub_question_id]: true,
                          }));
                          return;
                        }
                        if (currentlyShown && hideUnselectedNow) {
                          setHideUnselectedStates((prev) => ({
                            ...prev,
                            [subQ.sub_question_id]: false,
                          }));
                          setShowRegeneratedStates((prev) => ({
                            ...prev,
                            [subQ.sub_question_id]: true,
                          }));
                          return;
                        }
                      }}
                    >
                      <span>🆚</span>
                      <span>
                        {(() => {
                          const currentlyShown = !!showRegenerated;
                          const hideUnselectedNow = !!hideUnselected;
                          if (!currentlyShown) return "문항 재생성";
                          if (currentlyShown && !hideUnselectedNow) return "문항 숨기기";
                          if (currentlyShown && hideUnselectedNow) return "문항 비교하기";
                          return "문항 재생성";
                        })()}
                      </span>
                    </button>
                  )}
                </div>
                {bMode &&
                  isLastVisibleInBMode &&
                  !restAutoGenerated &&
                  (() => {
                    const totalSteps = (currentCotData as any)?.steps?.length ?? 8;
                    const hasNextStep = bCurrentIndex < totalSteps;
                    if (!hasNextStep) return null;
                    return (
                      <div className={styles.actionRowWorkflow}>
                        <button className={styles.generateButton} onClick={() => generateNextStepB()}>
                          확정 후 다음 문항 생성
                        </button>
                        <button className={styles.generateButton} onClick={() => generateRemainingStepsB()}>
                          확정 후 나머지 문항 자동 생성
                        </button>
                      </div>
                    );
                  })()}
              </div>

              {isFeedbackOpen && (
                <div className={styles.feedbackInput}>
                  <textarea className={`${styles.feedbackTextarea} feedback-textarea-${subQ.sub_question_id}`} rows={3} placeholder="수정 요청사항을 입력하세요." disabled={isRegenerating} />
                  <div className={styles.feedbackActions}>
                    <button className={styles.cancelBtn} onClick={() => toggleFeedback(subQ.sub_question_id)} disabled={isRegenerating}>
                      취소
                    </button>
                    <button
                      className={styles.submitBtn}
                      disabled={isRegenerating}
                      onClick={() => {
                        const feedbackText = (document.querySelector(`.feedback-textarea-${subQ.sub_question_id}`) as HTMLTextAreaElement)?.value || "";
                        if (feedbackText.trim()) {
                          handleFeedbackRegenerate(subQ.sub_question_id, feedbackText);
                        }
                      }}
                    >
                      {isRegenerating ? (
                        <>
                          <span className={styles.spinnerInline} aria-hidden />
                          처리 중...
                        </>
                      ) : (
                        "입력"
                      )}
                    </button>
                  </div>
                </div>
              )}

              {isVerificationOpen && (
                <div className={styles.verificationResult}>
                  {hasRegenerated && (
                    <div className={styles.verificationSection}>
                      <div className={styles.verificationTitle}>원본 문항 검증 결과</div>
                      <div
                        dangerouslySetInnerHTML={{
                          __html: formatVerificationResult(subQ.verification_result),
                        }}
                      />
                    </div>
                  )}
                  {hasRegenerated && (
                    <div className={styles.verificationSection}>
                      <div className={styles.verificationTitle}>재생성 문항 검증 결과</div>
                      <div
                        dangerouslySetInnerHTML={{
                          __html: formatVerificationResult(subQ.re_verification_result),
                        }}
                      />
                    </div>
                  )}
                  {!hasRegenerated && (
                    <div
                      dangerouslySetInnerHTML={{
                        __html: formatVerificationResult(subQ.verification_result),
                      }}
                    />
                  )}
                </div>
              )}
            </div>
          );
        })}
        {/* 문항 생성 중: 다음 문항이 나타날 자리(빈 영역)에 로딩 표시 */}
        {isGeneratingSteps && !loading && (
          <div className={styles.loadingPlaceholderCard}>
            <div className={styles.spinner}></div>
            <div>로딩 중...</div>
            {progress.total > 0 && (
              <div className={styles.progress}>
                {progress.currentStep} ({progress.current}/{progress.total})
              </div>
            )}
          </div>
        )}
      </div>
      {showFinalizeButton && (
        <div className={styles.finalizeRow}>
          <button type="button" className={styles.downloadBtn} onClick={handleDownloadJson}>
            JSON 다운로드
          </button>

          <button type="button" className={styles.finalizeBtn} onClick={handleFinalize}>
            하위문항 확정하기
          </button>
        </div>
      )}
      {showFinalizeButton && finalizedGuidelineForRubric != null && (
        <div className={styles.exportWordRow}>
          <button type="button" className={styles.exportWordBtn} onClick={handleExportWord}>
            Word 다운로드
          </button>
          <button type="button" className={styles.exportPdfBtn} onClick={handleExportPdf}>
            PDF 다운로드
          </button>
          <button type="button" className={styles.rubricGoBtn} onClick={handleGoToRubric}>
            루브릭 생성하기
          </button>
        </div>
      )}
    </div>
  );
};
